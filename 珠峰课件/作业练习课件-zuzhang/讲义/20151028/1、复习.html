<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    var num = 12;
    var ary = [1, 2, 3, 4];
    function fn(ary) {
        ary[0] = 0;
        ary = [0];
        ary[0] = 100;
        return ary;//把ary私有形参变量存储的值，返回到函数的外面
    }
    var res = fn(ary);//执行fn函数，并且把ary存储的地址xxxfff000传递给我们函数中的形参
    console.log(ary);
    console.log(res);


    //1、当浏览器开始加载我们页面的时候，首先会提供一个供全局JS代码执行的环境-->全局作用域(window/global)
    //"作用域":-->"栈内存"
    //1)提供一个供JS代码执行的环境
    //2)存储基本数据类型的值
    //JS中的作用域只有两种：全局作用域(浏览器加载页面就会形成)、私有作用域(只有函数执行才会形成)

    //2、代码从上到下执行
    //var num = 12; -->在全局作用域下定义一个变量num，值是12，12存储在全局作用域下

    //var ary = [1, 2, 3, 4]; -->在全局作用域下定义一个变量ary
    //  1)开辟一个新的内存空间,然后有一个地址,我们假设其为xxxfff000
    //  2)把数据中的索引和对应的值，分别的存储到我们的这个内存空间中
    //  3)在把空间地址赋值给我们的全局变量ary -->ary=xxxfff000
    //  -->在这里我们新开辟的这个内存xxxfff000是用来存储值的，我们把其称之为"堆内存"-->对象是把属性名和属性值分别的存储进去，而函数是把函数体中的代码当做"字符串"存进去

    //11~16行:在全局作用域下定义了一个叫做fn的函数(参考上面的三步)
    //  1)由于函数也是引用数据类型的，所以首先开辟一个新的堆内存，地址为xxxfff111
    //  2)把函数体中的代码当做"字符串"存储进来 -->函数只是定义了，里面存储的都是字符串，没有任何的实际意义
    //  3)在把地址赋值给全局下定义的函数名fn -->fn=xxxfff111

    //var res = fn(ary);  把函数fn执行的返回值,赋值给我们的res这个全局变量
    //  1)执行我们的fn
    //      a、函数执行首先会形成一个新的私有的作用域，供我们函数体中的代码执行，并且存储函数体中基本数据类型的值；在这里还传递了一个值，执行函数的时候把全局下ary存储的地址xxxfff000赋值给我们的形参变量；
    //      b、如果有形参变量的话，我们首先给形参赋值 -->给形参的变量ary赋值为xxxfff000 (形参是私有的变量，因为是在私有作用域中定义的形参)
    //      c、全局下ary=xxxfff000 私有的ary=xxxfff000 两个不同的变量其实操作的是同一个内存地址
    //      d、函数执行会形成一个私有的作用域，保护里面的私有变量不受外界的干扰(私有变量:形参、在函数体中var过的)；如果外面想用，我们只能通过return把需要的值返回；return ary -->把私有变量ary的值xxxfff222返回到函数的外面
    //  2、把函数的返回值赋值给我们的全局变量res --> res = xxxfff222


    //不管是变量的名字还是函数的名字，都是在当前的作用域下起的名字，所以如果一样了也算冲突，例如:
    //    var fn = 12;
    //    function fn() {
    //    }
    //这两个的fn我们只能留一个值，要不然就是12，要不然就是函数
</script>
</body>
</html>