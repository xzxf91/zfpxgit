<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //如何查找其上级作用域?
    //看当前的函数是在哪个作用域下定义的，那么它的上级作用域就是谁

    //    var num = 12;
    //    function fn() {
    //        var num = 13;
    //        return function () {
    //            console.log(num);
    //        }
    //    }
    //    var f = fn();
    //    f();


    //关于销毁问题:
    //1、全局作用域只有在关闭页面的时候才会销毁
    //2、函数对应的堆内存在没有变量引用的时候才会销毁，例如:
    //var obj={}; -->开了一个堆内存空间，然后把地址告诉给obj，此时obj就占用了这个堆内存，这个内存就不能销毁了
    //obj=null; -->把obj记住的地址给清掉，这样就没有人在占用这个堆内存了，在浏览器空闲的时候会把其销毁

    //3、一般情况下，我们函数执行完成，形成的私有作用域就会自己销毁

    //4、函数执行形成一个私有的作用域，在这个作用域外面有东西占用了作用域里面的内容，那么这个私有的作用域就不能销毁了
    //1)函数执行，返回了一个引用数据类型的值，并且在函数的外面有变量接收了这个返回值，那么当前fn形成的私有作用域就不能销毁了--->私有作用域中的所有变量也保留下来了
    //    function fn() {
    //        return function () {
    //        }
    //    }
    //    var f = fn();

    //5、不立即销毁的情况
    //函数执行返回了一个引用数据类型的值，但是外面没有变量接收，我只是把返回的值使用了一次，这样当前形成的作用域处于不立即销毁状态，当浏览器空闲的时候会把没用的统一进行销毁
    //    function fn() {
    //        return function (n) {
    //        }
    //    }
    //    fn()(15);


    //++i和i++的区别:
    //都是在自身的基础上加1
    //i++是先拿自身的值和其他的值进行运算，运算完成后本身在加1
    //++i是先自身累加1，然后拿累加后的结果和其他的值进行运算
    //var i = 2;
    //console.log(15 + i++);//15+i=17 -- i++ i=3
    //console.log(15 + (++i));//i++ i=3 -- 15+3=18

    //思考题：
    //    var i = 0;
    //    console.log(10 + (i++) + (i++) + (++i) + (++i));
    //    console.log(i);


    function fn() {
        var i = 10;
        return function (n) {
            console.log(n + (++i));
        }
    }
    var f = fn();
    f(15);//-->26
    f(20);//-->32
    fn()(15);//-->先执行fn，把返回的小函数紧接着在执行 -->26
    fn()(20);//-->31
</script>
</body>
</html>